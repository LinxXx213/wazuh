/*
 * Wazuh databaseFeedManager
 * Copyright (C) 2015, Wazuh Inc.
 * November 22, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "sendReport_test.hpp"
#include "../scanOrchestrator/sendReport.hpp"
#include "socketClient.hpp"
#include "socketServer.hpp"

const std::string TEST_PATH {"/tmp/socket"};
const size_t MAX_RETRIES {1000};

const std::string detectionStr =
    R"(
        {
            "data": {
                "agent": {
                "build": {
                    "original": "40800"
                },
                "ephemeral_id": "node01",
                "id": "001",
                "ip": "192.168.33.20",
                "name": "focal",
                "type": "wazuh",
                "version": "4.8.0"
                },
                "ecs": {
                "version": "8.11.0"
                },
                "package": {
                "architecture": " ",
                "build_version": "",
                "checksum": "",
                "description": " ",
                "install_scope": "",
                "install_time": " ",
                "license": "",
                "name": "PyYAML",
                "path": "/usr/lib/python3/dist-packages/PyYAML-5.3.1.egg-info",
                "reference": "",
                "size": 0,
                "type": "pypi",
                "version": "5.3.1"
                },
                "vulnerability": {
                "category": "Packages",
                "classification": "CVSS",
                "description": "A vulnerability was discovered in the PyYAML library in versions before 5.4, where it is susceptible to arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader. Applications that use the library to process untrusted input may be vulnerable to this flaw. This flaw allows an attacker to execute arbitrary code on the system by abusing the python/object/new constructor. This flaw is due to an incomplete fix for CVE-2020-1747.",
                "enumeration": "CVE",
                "id": "CVE-2020-14343",
                "reference": "https://bugzilla.redhat.com/show_bug.cgi?id=1860466, https://github.com/SeldonIO/seldon-core/issues/2252, https://github.com/yaml/pyyaml/issues/420, https://www.oracle.com/security-alerts/cpuapr2022.html, https://www.oracle.com/security-alerts/cpujul2022.html",
                "report_id": "",
                "scanner": {
                    "vendor": "Wazuh"
                },
                "score": {
                    "base": 9.800000190734863,
                    "environmental": 0.0,
                    "temporal": 0.0,
                    "version": "3.1"
                },
                "severity": "CRITICAL"
                }
            },
            "id": "node01_001_e793091be00d470d63406011b00de081543a28bc_CVE-2020-14343",
            "operation": "INSERTED"
    }
)";

#if 0
TEST_F(SendReportTest, SendFormattedMsg)
{
    const std::string report =
        R"(
            {
                "data": {
                    "vulnerability": {
                        "category": "Packages",
                        "classification": "CVSS",
                        "description": "A vulnerability was discovered in the PyYAML library in versions before 5.4, where it is susceptible to arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader. Applications that use the library to process untrusted input may be vulnerable to this flaw. This flaw allows an attacker to execute arbitrary code on the system by abusing the python/object/new constructor. This flaw is due to an incomplete fix for CVE-2020-1747.",
                        "enumeration": "CVE",
                        "id": "CVE-2020-14343",
                        "package": {
                            "architecture": " ",
                            "build_version": "",
                            "checksum": "",
                            "description": " ",
                            "install_scope": "",
                            "install_time": " ",
                            "license": "",
                            "name": "PyYAML",
                            "path": "/usr/lib/python3/dist-packages/PyYAML-5.3.1.egg-info",
                            "reference": "",
                            "size": 0,
                            "type": "pypi",
                            "version": "5.3.1"
                        },
                        "reference": "https://bugzilla.redhat.com/show_bug.cgi?id=1860466, https://github.com/SeldonIO/seldon-core/issues/2252, https://github.com/yaml/pyyaml/issues/420, https://www.oracle.com/security-alerts/cpuapr2022.html, https://www.oracle.com/security-alerts/cpujul2022.html",
                        "report_id": "",
                        "scanner": {
                            "vendor": "Wazuh"
                        },
                        "score": {
                            "base": 9.800000190734863,
                            "environmental": 0.0,
                            "temporal": 0.0,
                            "version": "3.1"
                        },
                        "severity": "CRITICAL"
                    }
                }
            }
        )";
    std::string expectedStr = "1:[001] (agent) 127.0.0.1->vulnerability-scanner:" + report;

    // Fake socket server
    auto thread = std::thread(
        [&]()
        {
            struct sockaddr_un serverAddr, clientAddr;

            int socketServer = socket(AF_UNIX, SOCK_DGRAM, 0);
            ASSERT_NE(socketServer, -1);

            serverAddr.sun_family = AF_UNIX;
            std::strcpy(serverAddr.sun_path, TEST_PATH.c_str());

            ASSERT_NE(bind(socketServer, (struct sockaddr*)&serverAddr, sizeof(serverAddr)), -1);

            char buffer[1024];
            size_t bytesReceived;
            socklen_t clientSize = sizeof(clientAddr);

            bytesReceived =
                recvfrom(socketServer, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &clientSize);

            ASSERT_NE(bytesReceived, -1);
            buffer[bytesReceived] = '\0';

            EXPECT_STREQ(buffer, expectedStr.c_str());

            close(socketServer);
            std::filesystem::remove(TEST_PATH);
        });

    nlohmann::json reportJson = nlohmann::json::parse(report);

    // Socket client instance.
    std::shared_ptr<SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper>> socketClient =
        std::make_shared<SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper>>(TEST_PATH);

    // Wait for server.
    struct stat fileStat;
    int statRet;
    size_t attemps = -1;
    do
    {
        ++attemps;
        statRet = stat(TEST_PATH.c_str(), &fileStat);
    } while (statRet != 0 && attemps < MAX_RETRIES);

    // Connect to server.
    socketClient->connect([](const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader) {},
                          SOCK_DGRAM);

    // Send report instance.
    SendReport sendReport(socketClient);

    // Mock scanContext.
    std::shared_ptr<ScanContext> scanContext;
    nlohmann::json detectionJson = nlohmann::json::parse(detectionStr);
    scanContext->m_elements["CVE-2020-14343"] = detectionJson;

    // Send report.
    sendReport.handleRequest(scanContext);

    thread.join();
}

TEST_F(SendReportTest, InvalidEncodingValue)
{
    std::string expectedString {"Couldn't send JSON report."};

    // Fake socket server
    auto thread = std::thread(
        [&]()
        {
            struct sockaddr_un serverAddr, clientAddr;

            int socketServer = socket(AF_UNIX, SOCK_DGRAM, 0);
            ASSERT_NE(socketServer, -1);

            serverAddr.sun_family = AF_UNIX;
            std::strcpy(serverAddr.sun_path, TEST_PATH.c_str());

            ASSERT_NE(bind(socketServer, (struct sockaddr*)&serverAddr, sizeof(serverAddr)), -1);

            char buffer[1024];
            size_t bytesReceived;
            socklen_t clientSize = sizeof(clientAddr);

            bytesReceived =
                recvfrom(socketServer, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &clientSize);

            ASSERT_NE(bytesReceived, -1);
            buffer[bytesReceived] = '\0';

            EXPECT_STREQ(buffer, expectedString.c_str());

            close(socketServer);
            std::filesystem::remove(TEST_PATH);
        });

    nlohmann::json reportJson;
    nlohmann::json packageObject;
    packageObject["name"] = "\xAA";
    reportJson["vulnerability"] = packageObject;

    SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper> socketClient {TEST_PATH};

    // Wait for server.
    struct stat fileStat;
    int statRet;
    size_t attemps = -1;
    do
    {
        ++attemps;
        statRet = stat(TEST_PATH.c_str(), &fileStat);
    } while (statRet != 0 || attemps < MAX_RETRIES);

    socketClient.connect([](const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader) {},
                         SOCK_DGRAM);

    try
    {
        VulnerabilityReport::sendReport(socketClient, reportJson, "001", "127.0.0.1", "agent");

        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        send(socketClient.getSocketDescriptor(), e.what(), strlen(e.what()), 0);
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }

    thread.join();
}
#endif
